= Migration to Mule 4: Recommended Post-Migration Tasks

The Migration tool performs migrations on individual components, connectors, and
modules. In some cases, you can improve the migrated application by taking into
account the flow or project as a whole.

This section focuses on some recommended post-migration tasks to perform after
using the Migration tool, incorporating the Compatibility module (see
link:migration-tool[Migrating Mule 3 Applications to Mule 4]) as needed, and
performing any manual migration steps indicated in the Migration report.

//TODO: REMOVE WHEN BETA IS OVER.
*Note on the Beta Release:* This page might be augmented periodically during the
Beta period based on feedback and recommendations.

== MEL Expressions

Most MEL expressions are migrated to link:dataweave[DataWeave] by the Migration
tool. However, some operators or MEL constructs are not supported by the migrator
to generate the equivalent DataWeave automatically.

For example, the expressions in the next Output examples receive the `mel:` prefix
from the migrator. The Compatibility module includes the MEL language from Mule 3,
so these expressions still work. The Manual Modification examples show how to
manually migrate the expressions in the Output examples to Mule 4.

.Example 1: Output of the Migration Tool
[source]
----
#[mel:flowVars.booleanVar ? 1 : 0]
----

.Example 2: Manual Modification to the Output of the Migration Tool
[source]
----
#[if (vars.booleanVar) 1 else 0]
----

.Example 1: Output of the Migration Tool
[source]
----
#[mel:Map m = new HashMap<>(); m.put(“key”, “value”); return m;]
----

.Example 2: Manual Modification to the Output of the Migration Tool
[source]
----
#[{‘key’, ‘value’}]
----

=== Using the Scripting Module to Migrate procedural MEL Expressions

Some MEL expressions are not simply expressions but actually procedural scripts,
so they cannot be migrated seamlessly to a functional language such as DataWeave.
For these cases, you should use the link:scripting-module[Scripting module] and
migrate the MEL script to a language supported by the Scripting module.

.Example: Output of the Migration Tool
[source,XML,linenums]
----
<expression-component><![CDATA[
if(flowVars.fail) {
    throw new IllegalStateException(“var fail is set to true”);
} else {
    payload = “Some Result”;
}
]]></expression-component>
----

.Example: Manual Modification to the Output of the Migration Tool
[source,XML,linenums]
----
<script:execute engine="groovy">
    <script:code><![CDATA[
if(vars.fail) {
    throw new IllegalStateException(“var fail is set to true”);
} else {
    payload = “Some Result”;
}
    ]]></script:code>
</script:execute>
----

Note that the content might look similar because MEL and Groovy syntax are
both Java-based, but always test that the behavior of any migrated script
is maintained.

== Inbound Properties (Manual Post-Migration Steps)

Instead of relying on the Compatibility module to handle inbound properties (see
link:intro-mule-message#inbound-properties-are-now-attributes[Inbound Properties Are Now Attributes])
and on the `mel:` syntax to allow MEL expressions in Mule 4, it is recommended that you follow each
of these steps on the Migration tool output:

. Remove `<compatibility:attributes-to-inbound-properties/>` elements.
. Replace uses of `inboundProperties` in MEL expressions with a DataWeave 2.0 expression.
. Replace uses of `vars.compatibility_inboundProperties[‘propName’]` with a reference to a Message attribute value.

This example shows modifications to inbound properties from an HTTP listener:

.Example: Output of the Migration Tool
[source,XML,linenums]
----
<http:listener config-ref="myHttp"/>
<compatibility:attributes-to-inbound-properties/>
<logger message="#[vars.compatibility_inboundProperties['http.request']]">
<logger message="#[mel:message.inboundProperties['http.request']]">
----

.Example: Manual Modification to the Output of the Migration Tool
[source,XML,linenums]
----
<http:listener config-ref="myHttp"/>
<logger message="#[message.attributes.requestPath]">
<logger message="#[message.attributes.requestPath]">
----

== Outbound Properties (Manual Post-Migration Steps)

If an outbound property is _not_ set in a flow, you can safely remove any
usage of that outbound property (see
link:intro-mule-message#outbound-properties[Outbound Properties]).
For example, you can remove the `status` attribute from an HTTP listener and
rely on the default for the listener _if_ an `http.status` outbound property is
never set in the flow.

//TODO: A BEFORE/AFTER EXAMPLE HERE WOULD HELP NICE.

If a property is set in the flow, you need to move the expression that sets the
property into the attribute of the operation or source where it is used. For
example, you might modify the XML output of the Migration tool:

.Example: Output of the Migration Tool
[source,XML,linenums]
----
<compatibility:set-property propertyName="http.method" value="#[if(get) 'GET' else 'PUT']"/>
...
<http:request config-ref="myHttp" method="#[vars.compatibility_outboundProperties['http.method']]"/>
----

The next example moves the expression that sets the `http.method` property
(shown in the example above) to the `method` attribute of the `http:request`
operation where it is used.

.Example: Manual Modification to the Output of the Migration Tool
[source,XML,linenums]
----
<http:request config-ref="myHttp" method="#[if(get) 'GET' else 'PUT']"/>
----

Note that in Mule 3, the outbound property can be set by any component or inside
a referenced flow. This kind of complexity makes the manual step necessary
because the Migration tool does not have the full context to interpret the
semantics of an application.
